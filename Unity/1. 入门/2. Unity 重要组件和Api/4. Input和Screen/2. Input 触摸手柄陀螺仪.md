# Unity Input è§¦æ‘¸ã€æ‰‹æŸ„ä¸é™€èºä»ªè¾“å…¥è¯¦è§£

## ä¸€ã€ç§»åŠ¨è®¾å¤‡ä¸å¤šå¹³å°è¾“å…¥æ¦‚è¿°

### 1.1 Unity Inputç³»ç»Ÿæ”¯æŒçš„è¾“å…¥è®¾å¤‡

Unity çš„ **Input ç±»**ä¸ä»…æ”¯æŒä¼ ç»Ÿçš„é¼ æ ‡å’Œé”®ç›˜ï¼Œè¿˜å…¨é¢å…¼å®¹ç°ä»£æ¸¸æˆå¼€å‘ä¸­å¸¸è§çš„å¤šç§è¾“å…¥æ–¹å¼ï¼š

- **è§¦æ‘¸å±ï¼ˆTouchï¼‰**ï¼šæ™ºèƒ½æ‰‹æœºå’Œå¹³æ¿è®¾å¤‡çš„ä¸»è¦äº¤äº’æ–¹å¼
- **æ¸¸æˆæ‰‹æŸ„ï¼ˆJoystick/Gamepadï¼‰**ï¼šä¸»æœºå’ŒPCæ¸¸æˆçš„æ ‡å‡†æ§åˆ¶å™¨
- **é™€èºä»ªï¼ˆGyroscopeï¼‰**ï¼šç§»åŠ¨è®¾å¤‡å’Œéƒ¨åˆ†é«˜ç«¯æ‰‹æŸ„ä¸­çš„ä½“æ„Ÿä¼ æ„Ÿå™¨

> ğŸ’¡ **æ ¸å¿ƒç†è§£**ï¼š  
> è¿™äº›è¾“å…¥æ–¹å¼è®©å¼€å‘è€…èƒ½å¤Ÿä¸ºä¸åŒå¹³å°ï¼ˆç§»åŠ¨ç«¯ã€ä¸»æœºã€PCï¼‰æä¾›**åŸç”Ÿä¸”æ²‰æµ¸å¼çš„äº¤äº’ä½“éªŒ**[ty-reference](1)ã€‚

---

### 1.2 å¤šå¹³å°è¾“å…¥æ£€æµ‹åŸåˆ™

åœ¨å¼€å‘è·¨å¹³å°æ¸¸æˆæ—¶ï¼Œéœ€è¦è€ƒè™‘ä»¥ä¸‹åŸåˆ™ï¼š

```csharp
void Update()
{
    // æ£€æµ‹å½“å‰è¿è¡Œå¹³å°ï¼Œé€‰æ‹©åˆé€‚çš„è¾“å…¥æ–¹å¼
    if (Application.isMobilePlatform)
    {
        HandleTouchInput();
    }
    else if (HasGamepadConnected())
    {
        HandleGamepadInput();
    }
    else
    {
        HandleKeyboardMouseInput();
    }
}
```

---

## äºŒã€è§¦æ‘¸è¾“å…¥ï¼ˆTouch Inputï¼‰

### 2.1 è§¦æ‘¸åŸºç¡€æ¦‚å¿µ

è§¦æ‘¸è¾“å…¥çš„æ ¸å¿ƒæ˜¯**å¤šç‚¹è§¦æ§**ï¼Œæ¯ä¸ªè§¦æ‘¸ç‚¹éƒ½åŒ…å«å®Œæ•´çš„ä½ç½®ã€çŠ¶æ€å’Œæ—¶é—´ä¿¡æ¯ã€‚

#### å¼€å¯å¤šç‚¹è§¦æ‘¸
```csharp
// å¯ç”¨å¤šç‚¹è§¦æ‘¸ï¼ˆé»˜è®¤å·²å¯ç”¨ï¼‰
Input.multiTouchEnabled = true;

// ç¦ç”¨å¤šç‚¹è§¦æ‘¸ï¼ˆåªå“åº”ç¬¬ä¸€ä¸ªè§¦æ‘¸ç‚¹ï¼‰
Input.multiTouchEnabled = false;
```

> ğŸŒŸ **æ³¨æ„**ï¼šå¤§å¤šæ•°ç°ä»£è®¾å¤‡é»˜è®¤æ”¯æŒå¤šç‚¹è§¦æ‘¸ï¼Œä½†æ˜¾å¼å¼€å¯å¯ç¡®ä¿å…¼å®¹æ€§[ty-reference](1)ã€‚

---

### 2.2 è§¦æ‘¸æ£€æµ‹ä¸å¤„ç†

#### åŸºç¡€è§¦æ‘¸æ£€æµ‹
```csharp
void Update()
{
    // æ£€æµ‹æ˜¯å¦æœ‰è§¦æ‘¸è¾“å…¥
    if (Input.touchCount > 0)
    {
        // è·å–ç¬¬ä¸€ä¸ªè§¦æ‘¸ç‚¹
        Touch firstTouch = Input.touches[0];
        
        // è·å–è§¦æ‘¸ä½ç½®ï¼ˆå±å¹•åæ ‡ï¼‰
        Vector2 touchPosition = firstTouch.position;
        Debug.Log($"è§¦æ‘¸ä½ç½®: {touchPosition}");
        
        // è·å–ç›¸å¯¹äºä¸Šä¸€å¸§çš„ä½ç½®å˜åŒ–
        Vector2 deltaPosition = firstTouch.deltaPosition;
        Debug.Log($"ä½ç½®å˜åŒ–: {deltaPosition}");
    }
}
```

#### è§¦æ‘¸ç›¸ä½ï¼ˆTouchPhaseï¼‰
æ¯ä¸ªè§¦æ‘¸ç‚¹éƒ½æœ‰æ˜ç¡®çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ï¼š

| ç›¸ä½ | è¯´æ˜ | å…¸å‹ç”¨é€” |
|------|------|----------|
| **Began** | æ‰‹æŒ‡åˆšæ¥è§¦å±å¹• | å¼€å§‹æ‹–æ‹½ã€ç‚¹å‡»æ£€æµ‹ |
| **Moved** | æ‰‹æŒ‡åœ¨å±å¹•ä¸Šç§»åŠ¨ | æ‹–æ‹½ã€æ»‘åŠ¨æ“ä½œ |
| **Stationary** | æ‰‹æŒ‡é™æ­¢æŒ‰ä½ | é•¿æŒ‰æ£€æµ‹ |
| **Ended** | æ‰‹æŒ‡ç¦»å¼€å±å¹• | ç»“æŸæ‹–æ‹½ã€ç¡®è®¤æ“ä½œ |
| **Canceled** | è§¦æ‘¸è¢«ç³»ç»Ÿå–æ¶ˆ | æ¸…ç†çŠ¶æ€ |

```csharp
void HandleTouchInput()
{
    foreach (Touch touch in Input.touches)
    {
        switch (touch.phase)
        {
            case TouchPhase.Began:
                OnTouchBegan(touch);
                break;
            case TouchPhase.Moved:
                OnTouchMoved(touch);
                break;
            case TouchPhase.Ended:
                OnTouchEnded(touch);
                break;
        }
    }
}

void OnTouchBegan(Touch touch)
{
    Debug.Log($"è§¦æ‘¸å¼€å§‹ï¼ŒID: {touch.fingerId}, ä½ç½®: {touch.position}");
    
    // å°„çº¿æ£€æµ‹ç‚¹å‡»å¯¹è±¡
    Ray ray = Camera.main.ScreenPointToRay(touch.position);
    if (Physics.Raycast(ray, out RaycastHit hit))
    {
        SelectObject(hit.collider.gameObject);
    }
}
```

---

### 2.3 å¤šç‚¹è§¦æ‘¸æ‰‹åŠ¿è¯†åˆ«

#### åŒæŒ‡ç¼©æ”¾ï¼ˆPinch Zoomï¼‰
```csharp
public class PinchZoom : MonoBehaviour
{
    private float initialDistance = 0f;
    private bool isPinching = false;
    
    void Update()
    {
        if (Input.touchCount == 2)
        {
            Touch touch1 = Input.touches[0];
            Touch touch2 = Input.touches[1];
            
            if (!isPinching && (touch1.phase == TouchPhase.Began || touch2.phase == TouchPhase.Began))
            {
                // å¼€å§‹åŒæŒ‡æ“ä½œ
                initialDistance = Vector2.Distance(touch1.position, touch2.position);
                isPinching = true;
            }
            else if (isPinching && (touch1.phase == TouchPhase.Moved || touch2.phase == TouchPhase.Moved))
            {
                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                float currentDistance = Vector2.Distance(touch1.position, touch2.position);
                float zoomFactor = currentDistance / initialDistance;
                
                // åº”ç”¨ç¼©æ”¾
                transform.localScale = Vector3.one * Mathf.Clamp(zoomFactor, 0.5f, 3f);
            }
            else if (touch1.phase == TouchPhase.Ended || touch2.phase == TouchPhase.Ended)
            {
                // ç»“æŸåŒæŒ‡æ“ä½œ
                isPinching = false;
            }
        }
    }
}
```

#### å•æŒ‡æ—‹è½¬
```csharp
public class TouchRotate : MonoBehaviour
{
    private Vector2 startTouchPos;
    private Quaternion startRotation;
    private bool isRotating = false;
    
    void Update()
    {
        if (Input.touchCount == 1)
        {
            Touch touch = Input.touches[0];
            
            if (touch.phase == TouchPhase.Began)
            {
                startTouchPos = touch.position;
                startRotation = transform.rotation;
                isRotating = true;
            }
            else if (touch.phase == TouchPhase.Moved && isRotating)
            {
                Vector2 delta = touch.position - startTouchPos;
                float rotationAngle = delta.x * 0.5f; // çµæ•åº¦è°ƒèŠ‚
                
                transform.rotation = startRotation * Quaternion.Euler(0, rotationAngle, 0);
            }
            else if (touch.phase == TouchPhase.Ended)
            {
                isRotating = false;
            }
        }
    }
}
```

---

## ä¸‰ã€æ‰‹æŸ„è¾“å…¥ï¼ˆGamepad/Joystick Inputï¼‰

### 3.1 æ‰‹æŸ„è¿æ¥æ£€æµ‹

#### è·å–è¿æ¥çš„æ‰‹æŸ„åˆ—è¡¨
```csharp
void CheckGamepadConnection()
{
    string[] joystickNames = Input.GetJoystickNames();
    
    if (joystickNames.Length > 0)
    {
        Debug.Log("æ£€æµ‹åˆ°æ‰‹æŸ„:");
        for (int i = 0; i < joystickNames.Length; i++)
        {
            Debug.Log($"æ‰‹æŸ„ {i}: {joystickNames[i]}");
        }
    }
    else
    {
        Debug.Log("æœªæ£€æµ‹åˆ°æ‰‹æŸ„");
    }
}
```

> âš ï¸ **æ³¨æ„**ï¼šæŸäº›æ‰‹æŸ„å¯èƒ½è¿”å›ç©ºå­—ç¬¦ä¸²åç§°ï¼Œä½†ä»èƒ½æ­£å¸¸å·¥ä½œ[ty-reference](2)ã€‚

---

### 3.2 æ‰‹æŸ„æŒ‰é”®æ£€æµ‹

æ‰‹æŸ„è¾“å…¥ä½¿ç”¨ä¸é”®ç›˜ç±»ä¼¼çš„æ£€æµ‹æ–¹æ³•ï¼Œä½†é€šè¿‡**è™šæ‹ŸæŒ‰é’®åç§°**è¿›è¡Œè®¿é—®ï¼š

```csharp
void Update()
{
    // ä½¿ç”¨é¢„å®šä¹‰çš„è™šæ‹ŸæŒ‰é’®
    if (Input.GetButtonDown("Jump"))      // é€šå¸¸æ˜ å°„åˆ°Aé”®/Xé”®
    {
        Jump();
    }
    
    if (Input.GetButton("Fire1"))         // é€šå¸¸æ˜ å°„åˆ°RT/R2
    {
        Shoot();
    }
    
    if (Input.GetButtonUp("Submit"))      // é€šå¸¸æ˜ å°„åˆ°Starté”®
    {
        PauseGame();
    }
}
```

#### è‡ªå®šä¹‰æ‰‹æŸ„æŒ‰é”®æ˜ å°„
åœ¨ **Edit â†’ Project Settings â†’ Input Manager** ä¸­å¯ä»¥é…ç½®æ‰‹æŸ„æŒ‰é”®æ˜ å°„ï¼š

- **Button 0-19**ï¼šå¯¹åº”æ‰‹æŸ„çš„å„ä¸ªç‰©ç†æŒ‰é”®
- **Axis 1-28**ï¼šå¯¹åº”æ‘‡æ†å’Œæ‰³æœºçš„æ¨¡æ‹Ÿè¾“å…¥

---

### 3.3 æ‰‹æŸ„è½´è¾“å…¥

#### æ‘‡æ†è¾“å…¥
```csharp
void HandleGamepadMovement()
{
    // å·¦æ‘‡æ†æ§åˆ¶ç§»åŠ¨
    float horizontal = Input.GetAxis("Horizontal"); // Xè½´
    float vertical = Input.GetAxis("Vertical");     // Yè½´
    
    Vector3 movement = new Vector3(horizontal, 0, vertical);
    playerController.Move(movement * moveSpeed * Time.deltaTime);
    
    // å³æ‘‡æ†æ§åˆ¶è§†è§’
    float lookX = Input.GetAxis("Mouse X"); // é€šå¸¸æ˜ å°„åˆ°å³æ‘‡æ†Xè½´
    float lookY = Input.GetAxis("Mouse Y"); // é€šå¸¸æ˜ å°„åˆ°å³æ‘‡æ†Yè½´
    
    cameraController.Rotate(lookY, lookX);
}
```

#### æ‰³æœºè¾“å…¥ï¼ˆAnalog Triggersï¼‰
```csharp
// æ£€æµ‹æ‰³æœºæŒ‰å‹åŠ›åº¦ï¼ˆèŒƒå›´0-1ï¼‰
float leftTrigger = Input.GetAxis("3rd Axis");  // LT/L2
float rightTrigger = Input.GetAxis("4th Axis"); // RT/R2

// å®ç°æ¸è¿›å¼åŠ é€Ÿ
float acceleration = rightTrigger - leftTrigger;
rigidbody.AddForce(transform.forward * acceleration * maxAcceleration);
```

---

## å››ã€é™€èºä»ªè¾“å…¥ï¼ˆGyroscope Inputï¼‰

### 4.1 é™€èºä»ªåŸºç¡€æ¦‚å¿µ

**é™€èºä»ª**æ˜¯ä¸€ç§è§’é€Ÿåº¦ä¼ æ„Ÿå™¨ï¼Œèƒ½å¤Ÿå®æ—¶æ£€æµ‹è®¾å¤‡çš„æ—‹è½¬è¿åŠ¨ã€‚åœ¨æ¸¸æˆä¸­çš„ä¸»è¦åº”ç”¨åŒ…æ‹¬ï¼š

- **ä½“æ„Ÿç„å‡†**ï¼šå€¾æ–œè®¾å¤‡æ§åˆ¶è§†è§’
- **èµ›è½¦è½¬å‘**ï¼šå€¾æ–œè®¾å¤‡æ§åˆ¶æ–¹å‘ç›˜
- **å¹³è¡¡æ¸¸æˆ**ï¼šæ§åˆ¶ç‰©ä½“ä¿æŒå¹³è¡¡
- **AR/VR**ï¼šå¤´éƒ¨è¿½è¸ªå’Œå§¿æ€æ£€æµ‹

> ğŸ’¡ **å·¥ä½œåŸç†**ï¼šé™€èºä»ªé€šè¿‡æµ‹é‡è®¾å¤‡ç»•ä¸‰ä¸ªè½´ï¼ˆpitchã€rollã€yawï¼‰çš„è§’é€Ÿåº¦æ¥ç¡®å®šæ—‹è½¬çŠ¶æ€[ty-reference](4)ã€‚

---

### 4.2 é™€èºä»ªå¯ç”¨ä¸æ£€æµ‹

#### å¯ç”¨é™€èºä»ª
```csharp
void Start()
{
    // æ£€æµ‹è®¾å¤‡æ˜¯å¦æ”¯æŒé™€èºä»ª
    if (SystemInfo.supportsGyroscope)
    {
        // å¯ç”¨é™€èºä»ª
        Input.gyro.enabled = true;
        
        // å¯é€‰ï¼šè®¾ç½®æ›´æ–°é¢‘ç‡ï¼ˆé»˜è®¤ä¸ºè®¾å¤‡æœ€å¤§é¢‘ç‡ï¼‰
        Input.gyro.updateInterval = 1.0f / 60.0f; // 60Hz
        
        Debug.Log("é™€èºä»ªå·²å¯ç”¨");
    }
    else
    {
        Debug.LogWarning("å½“å‰è®¾å¤‡ä¸æ”¯æŒé™€èºä»ªï¼");
    }
}
```

---

### 4.3 é™€èºä»ªæ•°æ®è·å–

#### ä¸»è¦APIå±æ€§
| å±æ€§ | è¿”å›ç±»å‹ | è¯´æ˜ |
|------|----------|------|
| **attitude** | Quaternion | è®¾å¤‡å½“å‰æ—‹è½¬å§¿æ€ï¼ˆå››å…ƒæ•°ï¼‰ |
| **rotationRate** | Vector3 | æ¯ç§’æ—‹è½¬é€Ÿåº¦ï¼ˆå¼§åº¦/ç§’ï¼‰ |
| **gravity** | Vector3 | é‡åŠ›åŠ é€Ÿåº¦å‘é‡ |
| **userAcceleration** | Vector3 | ç”¨æˆ·å¼•èµ·çš„åŠ é€Ÿåº¦ |

```csharp
void Update()
{
    if (Input.gyro.enabled)
    {
        // è·å–è®¾å¤‡æ—‹è½¬å§¿æ€
        Quaternion rotation = Input.gyro.attitude;
        
        // è·å–æ—‹è½¬é€Ÿåº¦
        Vector3 rotationRate = Input.gyro.rotationRate;
        
        // è·å–é‡åŠ›æ–¹å‘
        Vector3 gravity = Input.gyro.gravity;
        
        Debug.Log($"æ—‹è½¬: {rotation.eulerAngles}, é€Ÿåº¦: {rotationRate}");
    }
}
```

---

### 4.4 é™€èºä»ªå®é™…åº”ç”¨

#### ç¬¬ä¸€äººç§°æ‘„åƒæœºæ§åˆ¶
```csharp
public class GyroCamera : MonoBehaviour
{
    private bool gyroSupported;
    private Quaternion baseRotation = Quaternion.Euler(90, 0, 0);
    
    void Start()
    {
        gyroSupported = SystemInfo.supportsGyroscope;
        if (gyroSupported)
        {
            Input.gyro.enabled = true;
        }
    }
    
    void Update()
    {
        if (gyroSupported)
        {
            // åº”ç”¨é™€èºä»ªæ—‹è½¬åˆ°æ‘„åƒæœº
            transform.rotation = baseRotation * ConvertRotation(Input.gyro.attitude);
        }
    }
    
    // åæ ‡ç³»è½¬æ¢ï¼ˆå³æ‰‹ç³»â†’å·¦æ‰‹ç³» + ç«–å±æ ¡æ­£ï¼‰
    private static Quaternion ConvertRotation(Quaternion q)
    {
        return new Quaternion(q.x, q.y, -q.z, -q.w);
    }
}
```

#### ä½“æ„Ÿèµ›è½¦æ§åˆ¶
```csharp
public class GyroCarController : MonoBehaviour
{
    public float steeringSensitivity = 1f;
    private Rigidbody rb;
    
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        if (SystemInfo.supportsGyroscope)
        {
            Input.gyro.enabled = true;
        }
    }
    
    void FixedUpdate()
    {
        if (Input.gyro.enabled)
        {
            // ä½¿ç”¨è®¾å¤‡å€¾æ–œè§’åº¦æ§åˆ¶è½¬å‘
            float steering = -Input.gyro.attitude.eulerAngles.z * steeringSensitivity;
            steering = Mathf.Clamp(steering, -1f, 1f);
            
            // åº”ç”¨è½¬å‘åŠ›
            rb.AddTorque(Vector3.up * steering * turnForce);
        }
    }
}
```

---

## äº”ã€é«˜çº§æŠ€å·§ä¸æœ€ä½³å®è·µ

### 5.1 è¾“å…¥æ–¹å¼è‡ªåŠ¨åˆ‡æ¢

```csharp
public class AdaptiveInputManager : MonoBehaviour
{
    private bool useTouch = false;
    private bool useGyro = false;
    private bool useGamepad = false;
    
    void Start()
    {
        DetectInputMethods();
    }
    
    void DetectInputMethods()
    {
        // ç§»åŠ¨å¹³å°ä¼˜å…ˆä½¿ç”¨è§¦æ‘¸
        if (Application.isMobilePlatform)
        {
            useTouch = true;
            
            // æ£€æµ‹é™€èºä»ªæ”¯æŒ
            if (SystemInfo.supportsGyroscope)
            {
                useGyro = true;
            }
        }
        // æ£€æµ‹æ‰‹æŸ„è¿æ¥
        else if (Input.GetJoystickNames().Length > 0)
        {
            useGamepad = true;
        }
    }
    
    void Update()
    {
        if (useTouch) HandleTouchInput();
        if (useGyro) HandleGyroInput();
        if (useGamepad) HandleGamepadInput();
        
        // å¦‚æœæ²¡æœ‰ä¸“ç”¨è¾“å…¥ï¼Œå›é€€åˆ°é”®ç›˜é¼ æ ‡
        if (!useTouch && !useGamepad)
        {
            HandleKeyboardMouseInput();
        }
    }
}
```

---

### 5.2 é™€èºä»ªæ ¡å‡†

ç”±äºé™€èºä»ªå¯èƒ½å­˜åœ¨æ¼‚ç§»ï¼Œå»ºè®®æä¾›æ ¡å‡†åŠŸèƒ½ï¼š

```csharp
public class GyroCalibration : MonoBehaviour
{
    private Quaternion calibrationOffset;
    
    public void CalibrateGyro()
    {
        // å°†å½“å‰è®¾å¤‡å§¿æ€è®¾ä¸º"æ°´å¹³"å‚è€ƒç‚¹
        calibrationOffset = Quaternion.Inverse(Input.gyro.attitude);
    }
    
    Quaternion GetCalibratedAttitude()
    {
        return calibrationOffset * Input.gyro.attitude;
    }
}
```

---

### 5.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

| è¾“å…¥ç±»å‹ | æ€§èƒ½è€ƒè™‘ | ä¼˜åŒ–å»ºè®® |
|----------|----------|----------|
| **è§¦æ‘¸** | æ¯å¸§éå†æ‰€æœ‰è§¦æ‘¸ç‚¹ | ç¼“å­˜å¸¸ç”¨è§¦æ‘¸ç‚¹ï¼Œé¿å…é‡å¤è®¡ç®— |
| **æ‰‹æŸ„** | è½´å€¼å¹³æ»‘å¤„ç† | ä½¿ç”¨GetAxisè€ŒéGetAxisRawå‡å°‘æŠ–åŠ¨ |
| **é™€èºä»ª** | é«˜é¢‘æ›´æ–° | æ ¹æ®éœ€æ±‚è°ƒæ•´updateIntervalï¼Œé¿å…è¿‡åº¦é‡‡æ · |

> ğŸ’¡ **æœ€ä½³å®è·µ**ï¼š
> - **ç§»åŠ¨å¹³å°**ï¼šä¼˜å…ˆä½¿ç”¨è§¦æ‘¸+é™€èºä»ªç»„åˆ
> - **ä¸»æœºå¹³å°**ï¼šå……åˆ†åˆ©ç”¨æ‰‹æŸ„çš„æ¨¡æ‹Ÿè¾“å…¥ç‰¹æ€§
> - **PCå¹³å°**ï¼šæä¾›æ‰‹æŸ„å’Œé”®é¼ åŒè¾“å…¥æ”¯æŒ
> - **è·¨å¹³å°**ï¼šæŠ½è±¡è¾“å…¥é€»è¾‘ï¼Œä¾¿äºåˆ‡æ¢è¾“å…¥æ–¹å¼

---

## å…­ã€å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 6.1 å¸¸è§é—®é¢˜

| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| é™€èºä»ªæ— å“åº” | æœªå¯ç”¨æˆ–è®¾å¤‡ä¸æ”¯æŒ | æ£€æŸ¥SystemInfo.supportsGyroscopeå¹¶å¯ç”¨Input.gyro.enabled |
| æ‰‹æŸ„æŒ‰é”®æ— æ•ˆ | è™šæ‹Ÿè½´é…ç½®é”™è¯¯ | åœ¨Input Managerä¸­æ­£ç¡®æ˜ å°„æ‰‹æŸ„æŒ‰é”® |
| è§¦æ‘¸æ£€æµ‹å¤±è´¥ | å¤šç‚¹è§¦æ‘¸æœªå¯ç”¨ | è®¾ç½®Input.multiTouchEnabled = true |
| é™€èºä»ªåæ ‡é”™è¯¯ | åæ ‡ç³»ä¸åŒ¹é… | è¿›è¡Œå³æ‰‹ç³»åˆ°å·¦æ‰‹ç³»çš„è½¬æ¢ |
| æ‰‹æŸ„è¿æ¥å»¶è¿Ÿ | ç³»ç»Ÿè¯†åˆ«æ—¶é—´ | åœ¨æ¸¸æˆå¼€å§‹å‰é¢„æ£€æµ‹æ‰‹æŸ„è¿æ¥ |

---

### 6.2 è°ƒè¯•å·¥å…·

```csharp
public class InputDebugger : MonoBehaviour
{
    void OnGUI()
    {
        GUILayout.Label("=== è¾“å…¥çŠ¶æ€è°ƒè¯• ===");
        
        // è§¦æ‘¸ä¿¡æ¯
        GUILayout.Label($"è§¦æ‘¸æ•°é‡: {Input.touchCount}");
        if (Input.touchCount > 0)
        {
            Touch t = Input.touches[0];
            GUILayout.Label($"è§¦æ‘¸ç›¸ä½: {t.phase}, ä½ç½®: {t.position}");
        }
        
        // æ‰‹æŸ„ä¿¡æ¯
        string[] joysticks = Input.GetJoystickNames();
        GUILayout.Label($"æ‰‹æŸ„æ•°é‡: {joysticks.Length}");
        for (int i = 0; i < Mathf.Min(joysticks.Length, 3); i++)
        {
            GUILayout.Label($"æ‰‹æŸ„{i}: {joysticks[i]}");
        }
        
        // é™€èºä»ªä¿¡æ¯
        if (Input.gyro.enabled)
        {
            GUILayout.Label($"é™€èºä»ªæ—‹è½¬: {Input.gyro.attitude.eulerAngles}");
            GUILayout.Label($"æ—‹è½¬é€Ÿåº¦: {Input.gyro.rotationRate}");
        }
    }
}
```

---

## ä¸ƒã€æ€»ç»“ï¼šå¤šå¹³å°è¾“å…¥é»„é‡‘æ³•åˆ™

1. **å¹³å°é€‚é…**ï¼šæ ¹æ®è¿è¡Œå¹³å°é€‰æ‹©æœ€åˆé€‚çš„è¾“å…¥æ–¹å¼
2. **è§¦æ‘¸å¤„ç†**ï¼šæ­£ç¡®å¤„ç†TouchPhaseç”Ÿå‘½å‘¨æœŸï¼Œæ”¯æŒå¤šç‚¹æ‰‹åŠ¿
3. **æ‰‹æŸ„ä¼˜åŒ–**ï¼šå……åˆ†åˆ©ç”¨æ¨¡æ‹Ÿè½´çš„è¿ç»­è¾“å…¥ç‰¹æ€§
4. **é™€èºä»ªæ ¡å‡†**ï¼šå¤„ç†åæ ‡ç³»è½¬æ¢ï¼Œæä¾›ç”¨æˆ·æ ¡å‡†é€‰é¡¹
5. **è¾“å…¥æŠ½è±¡**ï¼šå°†å…·ä½“è¾“å…¥æ–¹å¼å°è£…ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
6. **æ€§èƒ½è€ƒè™‘**ï¼šåˆç†è®¾ç½®é™€èºä»ªé‡‡æ ·ç‡ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—
7. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›å¤šç§è¾“å…¥æ–¹å¼æ”¯æŒï¼Œè®©ç©å®¶è‡ªç”±é€‰æ‹©

> âœ¨ **ç»ˆææç¤º**ï¼š  
> "ç°ä»£æ¸¸æˆè¾“å…¥å·²ç»è¶…è¶Šäº†ä¼ ç»Ÿçš„é”®é¼ é™åˆ¶ï¼Œ  
> æŒæ¡è§¦æ‘¸ã€æ‰‹æŸ„ã€é™€èºä»ªçš„ç»¼åˆè¿ç”¨ï¼Œ  
> ä½ å°±èƒ½ä¸ºä¸åŒå¹³å°çš„ç©å®¶æä¾›**è‡ªç„¶ã€ç›´è§‚ã€æ²‰æµ¸**çš„äº¤äº’ä½“éªŒï¼›  
> ç”¨å¥½è¿™äº›æŠ€æœ¯ï¼Œä½ çš„æ¸¸æˆå°†çœŸæ­£å®ç°**å…¨å¹³å°æ— ç¼é€‚é…**ï¼"